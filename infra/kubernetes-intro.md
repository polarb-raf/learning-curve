#kubernetes 소개

`쿠버네티스 인 액션`이라는 책의 1장 `쿠버네티스 소개` 부분을 읽고 간단히 요약한다.  
실제 사용 예제가 없이, 간단한 배경 설명 및 개념 설명만을 요약한다.

> 쿠버네티스는 조종사, 조타수를 뜻하는 그리스어

## 배경

1. Monolith 에서 Microservice로 전환
    - monolith는 모든 것이 하나로 강하게 결합되어 있기 때문에 한 부분만 변경하더라도 전체 앱을 재배포해야 하며, 시간이 지남에 따라 구성 요소간의 경계가 불분명해지고, 상호 의존성이 증가하게 된다.
    - scale up, scale out하기 어려움.
    - 서비스를 정적인 외부 api를 제공하는 독립형 프로세스들로 나누어 개발하는 마이크로서비스가 유행.

2. microservice의 복잡성 증가
    - 배포 가능한 구성 요소가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리, 유지하는 일이 점점 어려워졌다.
    - 독립적으로 배포 될 뿐 아니라 독립적으로 개발되기 때문에 환경 요구 사항이 다양해진다.
    - 리소스 활용률을 높이고 하드웨어 비용을 낮추며 각 구성 요소를 배치할 위치를 파악하는 것은 더욱 어렵다.
    - devOps? noOps?
    - 이런 구성 요소의 서버 배포를 자동으로 스케줄링하고 구성, 관리, 장애 처리를 포함하는 자동화를 가능케 하는 것이 쿠버네티스.

3. 쿠버네티스가 최고시다
    - 쿠버네티스는 개발자가 운영 팀의 도움이 없이도 자신의 애플리케이션을 원하는 만큼 자주 배포할 수 있도록 한다.
    - 하드웨어 장애 발생 시 해당 에플리케이션을 자동으로 모니터링하고 스케줄링을 조절한다.
    - 쿠버네티스는 하드웨어 인프라를 추상화하고 데이터 센터 전체를 하나의 거대한 컴퓨팅 리소스로 제공한다. 실제 세세한 서버 정보를 알 필요 없이 애플리케이션 구성 요소를 배포하고 실행할 수 있다.
    - 쿠버네티스로 여러 애플리케이션 구성 요소를 배포할 때 각 구성 요소 서버를 선택하고 배포하며 애플리케이션의 다른 구성 요소를 쉽게 찾고 통신할 수 있게 한다.

> 자꾸 '쿠버네티스를 이용하면 이 모든 것을 해결할 수 있다'고 해서 좀...ㅎㅎ

## 컨테이너 기술 소개
- 다들 아시는 부분일거라 생략
- (대충 컨테이너가 이렇게 좋다는 내용)
- 기존의 가상 머신과 비교해서~~ blah blah
- 이미지 레이어가 어쩌구 저쩌구

## 쿠버네티스의 기원
- 구글이 자체적으로 개발한 보그(borg, 후에 오메가로 바뀜)를 비밀로 유지하다가 2014년에 보그, 오메가, 기타 내부 구글 시스템으로 얻은 경험을 기반으로 하는 오픈소스 시스템인 쿠버네티스 출시

## 쿠버네티스
- 쿠버네티스는 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템이다.
- 쿠버네티스를 사용하면 모든 노드가 하나의 거대한 컴퓨터인 것처럼 수천 대의 컴퓨터 노트에서 소프트웨어 어플리케이션을 실행할 수 있다. 기본 인프라를 추상화하고 개발과 운영 팀 모두의 개발, 배포, 관리를 단순화한다.
- 클러스터에 노드가 몇 개만 있든 수천 개가 있든, 쿠버네티스에 애플리케이션을 배포하는 것은 항상 동일하다.
- 원하는 상태를 선언하는 `선언적`방식, 목표를 달성하기 위한 방법은 쿠버네티스가 알아서 판단하고 적용.

## 쿠버네티스 핵심 이해
- 클러스터는 마스터(컨트롤 플레인) 노드와 한 개 이상의 워커 노드로 구성된다.
- 애플리케이션 매니페스트를 게시하면 쿠버네티스는 해당 애플리케이션을 워커 노드 클러스터에 배포한다.
- 여러 애플리케이션은 클러스터에 걸쳐 분산되지만 배포된 위치에 상관없이 동일한 방식으로 서로 통신할 수 있다.

## 쿠버네티스 클러스터 아키텍쳐 이해
- [참고: 쿠버네티스 공식 페이지](https://kubernetes.io/ko/docs/concepts/overview/components/)
- 마스터 노드는 전체 쿠버네티스 시스템을 제어하고 관리하는 컨트롤 플레인을 실행한다.
- 워커 노드는 실제 배포되는 컨테이너 애플리케이션을 실행한다. 노드는 클러스터에 따라 VM이 될 수도 있고, 물리 머신이 될 수도 있다. 

1. 컨트롤 플레인
    - 쿠버네티스 api 서버는 사용자, 컨트롤 플레인 구성 요소와 통신한다.
    - 스케줄러는 애플리케이션의 배포를 담당한다(애플리케이션의 배포 가능한 각 구성 요소를 워크 노드에 할)당
    - 컨트롤러 매니저는 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행한다.
    - etcd는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소다.(key-value)
    - cloud-controller-manager는 바탕을 이루는 클라우드 제공사업자와 상호작용하는 컨트롤러를 작동시킨다. cloud-controller-manager 바이너리는 쿠버네티스 릴리스 1.6에서 도입된 알파 기능이다.
    - 컨트롤 플레인의 구성 요소는 **클러스터를 유지하고 제어하지만 애플리케이션을 실행하진 않는다.**
    
2. 노드
    - 컨테이너화된 애플리케이션을 실행하는 시스템
    - 컨테이너 런타임(docker, rkt 등), kubelet, kube-proxy로 구성
    - kubelet은 api서버와 통신하고 노드의 컨테이너를 관리한다.
    - kube-proxy는 애플리케이션 구성 요소 간 네트워크 트래픽을 로드밸런싱한다.
    

## 쿠버네티스에서 애플리케이션 실행
- 컨테이너 이미지는 이미 준비되어 레지스트리에 푸시되어 있어야 함.(쿠버네티스는 빌드나 배포에 직접 관여하지 않는다)
- 쿠버네티스 api에 애플리케이션 디스크립션을 게시해야 함
- 이 디스크립션에는 컨테이너 이미지, 애플리케이션 구성 요소가 포함된 이미지, 구성 요소간 통신하는 방법, 동일 서버에 함께 배치되어야 하는 구성 요소와 같은 정보가 포함된다.
- 각 구성 요소의 복제본 수도 정할 수 있다.

1. 디스크립션 게시
    - api가 디스크립션을 처리할 때 스케줄러는 각 컨테이너에 필요한 리소스를 계산하고 해당 시점에 각 노드에 할당되지 않은 리소스를 기반으로 사용 가능한 워커 노드에 지정된 컨테이너를 할당
    - 해당 노드의 kubelet은 필요한 컨테이너 이미지를 가져와 실행하도록 지시한다.
    - [이미지 참조](https://post.naver.com/viewer/postView.nhn?volumeNo=28113395&memberNo=36733075)

2. 실행된 컨테이너 유지
    - 실행 이후 쿠버네티스는 배포 상태가 사용자가 제공한 디스크립션과 일치하는지 지속적으로 확인한다.
    - 프로세스가 중단되거나 응답이 중지될 때와 같이 인스턴스가 제대로 작동하지 않으면 자동으로 다시 시작한다.
    - 워커 노드 전체가 종료되거나 액세스할 수 없게 되면 노드에서 실행중인 모든 컨테이너의 노드를 새로 스케줄링하고, 새로 실행한다.
3. 복제본 수 스케일링
    - 실행되는 동안 복제본 수를 늘릴지 줄일지 결정할 수 있으며, 복제본 수만 선언하면 쿠버네티스가 알아서 맞춰준다.
    - 최적의 복제본 수를 결정하는 작업을 쿠버네티스에 맡길 수도 있다. cpu 부하, 메모리 사용량, 초당 요청 수 등의 정보를 기반으로 복제본 수를 자동으로 조정할 수 있다.


## 쿠버네티스 사용의 장점
1. 애플리케이션 배포의 단순화
    - 쿠버네티스는 모든 워커 노드를 하나의 배포 플랫폼으로 제공하기 때문에 개발자는 자체적으로 배포를 시작할 수 있으며 클러스터를 구성하는 서버에 대해서 알 필요가 없다..(?)
    - 서버는 애플리케이션에 적절한 시스템 리소스를 제공할 수 있는 한 애플리케이션이 어느 서버에서 실행 중인지 신경 쓰지 않는다.
    - 애플리케이션이 특정 종류의 하드웨어에서 실행되어야 하는 경우(예: 어떤 앱은 SSD에서 실행되어야 하고 어떤 앱은 HDD에서 실행해야 하는 경우) 역시 쿠버네티스에게 알려주기만 하면 알아서 ssd가 있는 노드 중에 하나를 선택한다.
    
2. 하드웨어 활용도 높이기
    - 컨테이너를 사용하고 앱을 클러스터의 특정 노드로 지정하지 않으면 언제든지 앱이 클러스터 간에 자유롭게 이동할 수 있으므로 클러스터에서 실행되는 다른 앱 구성 요소를 혼합해 노드에 배치할 수 있다.
    - 하드웨어 리소스를 최대한 활용할 수 있다는 뜻.

3. 상태 확인과 자가 치유
    - 쿠버네티스는 앱 구성 요소와 앱이 구동 중인 노드를 모니터링하다가 장애 발생 시 자동으로 앱을 다른 노드로 스케줄링한다. 
    - 이로써 운영팀은 앱 구성 요소를 수동으로 마이그레이션할 필요가 없어지고, 앱을 재배치하는 즉시 노드 자체를 수정해 사용 가능한 하드웨서 리소스 풀에 반환하는데 집중할 수 있다.
    - **인프라에 장애가 발생한 노드가 없어도 정상적인 시스템 작동이 가능하도록 충분한 예비 자원이 있는 경우 운영 팀은 새벽 3시에 일어난 장애에 즉시 대응할 필요가 없다(!)**

4. 오토스케일링
    - 급격한 부하 급증에 대응하기 위해 개별 앱의 부하를 지속적으로 모니터링 할 필요가 없다.
    - 클라우드 인프라에서 쿠버네티스가 실행 중인 경우 클라우드 제공업체의 api로 쉽게 노드를 추가하면 배포된 앱의 부하에 따라 전체 클러스터의 크기를 자동으로 확장, 축소할 수 있다.

5. 앱 개발 단순화
    - 이건 잘 이해가 안되어서..

## 결론은..? 생각해 볼 점?
- 쿠버네티스 짱짱맨이긴 한데... 너무 좋다 좋다 하니까 오히려 의심이 가는 상황?
- 쿠버네티스 자체의 장점은 사실 명확하겠지만, 우리 시스템을 쿠버네티스로 옮김으로 인해 얼마나 이득을 볼 수 있을까?
- 감상: 책이 1000페이지에 달하는데 아직 100페이지도 읽지 못했고, 실제 프로덕션에서 활용하려면 얼마나 시간을 걸려서 습득해야 할지 감이 오지 않는다.
